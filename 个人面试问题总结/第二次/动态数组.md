# 动态数组扩容和收缩

> （这里指o1时间用下标访问）

**动态数组** 是一种动态存储的线性表，所有元素的内存地址都是连续的。（我之前理解的是链表，实际上动态数组是线性表的。。。）

## 扩容

ArrayList内部有个elementData的Object数组，初始容量在Java 8中为10。当第11个数据需要添加时候，扩容1.5倍。这个1.5倍在ArrayList很巧妙，用了整数移位的方式。

```java
int newCapacity = oldCapacity + (oldCapacity >> 1);
```

完整的代码如下;

```java
private void grow(int minCapacity) {
	// overflow-conscious code
	int oldCapacity = elementData.length;
	int newCapacity = oldCapacity + (oldCapacity >> 1);
	if (newCapacity - minCapacity < 0)
		newCapacity = minCapacity;
	if (newCapacity - MAX_ARRAY_SIZE > 0)
		newCapacity = hugeCapacity(minCapacity);
	// minCapacity is usually close to size, so this is a win:
	elementData = Arrays.copyOf(elementData, newCapacity);
}
```

## 收缩

收缩数组的目的是为了节省内存，但是牺牲了时间。比如每一次的删除元素，都会触发一次System.arraycopy重写elementData，移动数组下标，再给无效的下标数据置空，隐式地等待gc清理。

```java
public E remove(int index) {
	rangeCheck(index);
	modCount++;
	E oldValue = elementData(index);
	int numMoved = size - index - 1;
	if (numMoved > 0)
		System.arraycopy(elementData, index+1, elementData, index,
						 numMoved);
	elementData[--size] = null; // clear to let GC do its work
	return oldValue;
}
```

另外，ArrayList还提供了一个显式的收缩方法trimToSize，将elementData的容量大小（elementData.length）收缩为实际大小（ArrayList.size()）。

```java
public void trimToSize() {
	modCount++;
	if (size < elementData.length) {
		elementData = Arrays.copyOf(elementData, size);
	}
}
```

# go的动态数组扩容原理

golang是以什么策略扩容的

append的时候发生扩容的动作

- append单个元素，或者append少量的多个元素，这里的少量指double之后的容量能容纳，这样就会走以下扩容流程，不足1024，双倍扩容，超过1024的，1.25倍扩容。
- 若是append多个元素，且double后的容量不能容纳，直接使用预估的容量。

**敲重点！！！！此外，以上两个分支得到新容量后，均需要根据slice的类型size，算出新的容量所需的内存情况`capmem`，然后再进行`capmem`向上取整，得到新的所需内存，除上类型size，得到真正的最终容量,作为新的slice的容量。**

> 参考

[ArrayList的动态数组扩容与收缩 | xzoO.Org](http://xzoo.org/posts/java-arraylist-capacity/)

[Go slice扩容深度分析 (juejin.cn)](https://juejin.cn/post/6844903812331732999)