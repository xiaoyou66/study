

[æ‰‹æŠŠæ‰‹å¸¦ä½ åˆ·äºŒå‰æ ‘ï¼ˆç¬¬ä¸€æœŸï¼‰ - labuladongçš„ç®—æ³•å°æŠ„ (gitbook.io)](https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/shou-ba-shou-shua-er-cha-shu-xun-lian-di-gui-si-wei/er-cha-shu-xi-lie-1)

# ç¿»è½¬äºŒå‰æ ‘

```
è¾“å…¥
	 4
   /   \
  2     7
 / \   / \
1   3 6   9

è¾“å‡ºï¼š

     4
   /   \
  7     2
 / \   / \
9   6 3   1

```

ä»£ç å¦‚ä¸‹ï¼š

```java
// å°†æ•´æ£µæ ‘çš„èŠ‚ç‚¹ç¿»è½¬
static TreeNode invertTree(TreeNode root) {
    // base case
    if (root == null) {
        return null;
    }

    /**** å‰åºéå†ä½ç½® ****/
    // root èŠ‚ç‚¹éœ€è¦äº¤æ¢å®ƒçš„å·¦å³å­èŠ‚ç‚¹
    TreeNode tmp = root.left;
    root.left = root.right;
    root.right = tmp;
    // è®©å·¦å³å­èŠ‚ç‚¹ç»§ç»­ç¿»è½¬å®ƒä»¬çš„å­èŠ‚ç‚¹
    invertTree(root.left);
    invertTree(root.right);
    return root;
}

public static void main(String[] args) {
    // è¿™é‡Œæˆ‘ä»¬åˆå§‹åŒ–æ ‘
    TreeNode root = new TreeNode(1);
    root.left = new TreeNode(2);
    root.right = new TreeNode(7);
    root.left.left = new TreeNode(1);
    root.left.right = new TreeNode(3);
    root.right.left = new TreeNode(6);
    root.right.right = new TreeNode(9);

    TreeNode result = invertTree(root);
    System.out.println(result);
}
```

è¿™ä¸ªé¢˜ç›®æ˜¯é€’å½’çš„å·§å¦™è¿ç”¨

# å¡«å……äºŒå‰æ ‘èŠ‚ç‚¹çš„å³ä¾§æŒ‡é’ˆ

![image-20210128105712084](images/image-20210128105712084.png)

![image-20210129085138371](images/image-20210129085138371.png)

æˆ‘ä»¬çš„å‡½æ•°å®šä¹‰å¦‚ä¸‹

```
// ä¸»å‡½æ•°
Node connect(Node root) {
    if (root == null) return null;
    connectTwoNode(root.left, root.right);
    return root;
}

// è¾…åŠ©å‡½æ•°
void connectTwoNode(Node node1, Node node2) {
    if (node1 == null || node2 == null) {
        return;
    }
    /**** å‰åºéå†ä½ç½® ****/
    // å°†ä¼ å…¥çš„ä¸¤ä¸ªèŠ‚ç‚¹è¿æ¥
    node1.next = node2;

    // è¿æ¥ç›¸åŒçˆ¶èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹
    connectTwoNode(node1.left, node1.right);
    connectTwoNode(node2.left, node2.right);
    // è¿æ¥è·¨è¶Šçˆ¶èŠ‚ç‚¹çš„ä¸¤ä¸ªå­èŠ‚ç‚¹
    connectTwoNode(node1.right, node2.left);
}
```



# äºŒå‰æ ‘å±•å¼€ä¸ºé“¾è¡¨

![image-20210129085834867](images/image-20210129085834867.png)

å…³é”®ä»£ç å¦‚ä¸‹

```java
// å®šä¹‰ï¼šå°†ä»¥ root ä¸ºæ ¹çš„æ ‘æ‹‰å¹³ä¸ºé“¾è¡¨
void flatten(TreeNode root) {
    // base case
    if (root == null) return;

    flatten(root.left);
    flatten(root.right);

    /**** ååºéå†ä½ç½® ****/
    // 1ã€å·¦å³å­æ ‘å·²ç»è¢«æ‹‰å¹³æˆä¸€æ¡é“¾è¡¨
    TreeNode left = root.left;
    TreeNode right = root.right;

    // 2ã€å°†å·¦å­æ ‘ä½œä¸ºå³å­æ ‘
    root.left = null;
    root.right = left;

    // 3ã€å°†åŸå…ˆçš„å³å­æ ‘æ¥åˆ°å½“å‰å³å­æ ‘çš„æœ«ç«¯
    TreeNode p = root;
    while (p.right != null) {
        p = p.right;
    }
    p.right = right;
}
```

ä½ çœ‹ï¼Œè¿™å°±æ˜¯é€’å½’çš„é­…åŠ›ï¼Œä½ è¯´ `flatten` å‡½æ•°æ˜¯æ€ä¹ˆæŠŠå·¦å³å­æ ‘æ‹‰å¹³çš„ï¼Ÿè¯´ä¸æ¸…æ¥šï¼Œä½†æ˜¯åªè¦çŸ¥é“ `flatten` çš„å®šä¹‰å¦‚æ­¤ï¼Œç›¸ä¿¡è¿™ä¸ªå®šä¹‰ï¼Œè®© `root` åšå®ƒè¯¥åšçš„äº‹æƒ…ï¼Œç„¶å `flatten` å‡½æ•°å°±ä¼šæŒ‰ç…§å®šä¹‰å·¥ä½œã€‚å¦å¤–æ³¨æ„é€’å½’æ¡†æ¶æ˜¯ååºéå†ï¼Œå› ä¸ºæˆ‘ä»¬è¦å…ˆæ‹‰å¹³å·¦å³å­æ ‘æ‰èƒ½è¿›è¡Œåç»­æ“ä½œã€‚

[æ‰‹æŠŠæ‰‹å¸¦ä½ åˆ·äºŒå‰æ ‘ï¼ˆç¬¬äºŒæœŸï¼‰ - labuladongçš„ç®—æ³•å°æŠ„ (gitbook.io)](https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/shou-ba-shou-shua-er-cha-shu-xun-lian-di-gui-si-wei/er-cha-shu-xi-lie-2)

# æœ€å¤§äºŒå‰æ ‘

```java
    // æ„å»ºæœ€å¤§äºŒå‰æ ‘
    static TreeNode constructMaximumBinaryTree(int[] nums) {
        // è¿™é‡Œæˆ‘ä»¬éœ€è¦é€šè¿‡ä¸€ä¸ªä»£ç†å‡½æ•°æ¥è¿›è¡Œæ„å»ºï¼Œå› ä¸ºæˆ‘ä»¬éœ€è¦ä¼ å…¥æ„å»ºçš„ lowèŠ‚ç‚¹å’ŒhighèŠ‚ç‚¹
        return build(nums, 0, nums.length - 1);
    }

    /* å°† nums[lo..hi] æ„é€ æˆç¬¦åˆæ¡ä»¶çš„æ ‘ï¼Œè¿”å›æ ¹èŠ‚ç‚¹ */
    static TreeNode build(int[] nums, int lo, int hi) {
        // base case
        // å½“low å¤§äºhighçš„æ—¶å€™ï¼Œè·³å‡ºå¾ªç¯
        if (lo > hi) {
            return null;
        }

        // æ‰¾åˆ°æ•°ç»„ä¸­çš„æœ€å¤§å€¼å’Œå¯¹åº”çš„ç´¢å¼•ï¼ˆä¸ºäº†é¿å…maxvalæŸ¥æ‰¾å‡ºé”™ï¼Œæˆ‘ä»¬ä½¿ç”¨Integer.MIN_VALUEæ¥è¡¨ç¤ºæœ€å°å€¼ï¼‰
        int index = -1, maxVal = Integer.MIN_VALUE;
        // åœ¨æˆ‘ä»¬æŒ‡å®šçš„èŒƒå›´å†…æ‰¾å‡ºæœ€å¤§å€¼       
        for (int i = lo; i <= hi; i++) {
            if (maxVal < nums[i]) {
                index = i;
                maxVal = nums[i];
            }
        }
//        æ‰¾åˆ°æœ€å¤§å€¼åæˆ‘ä»¬åˆ›å»ºä¸€ä¸ªæ ‘èŠ‚ç‚¹
        TreeNode root = new TreeNode(maxVal);
        // é€’å½’è°ƒç”¨æ„é€ å·¦å³å­æ ‘ï¼ˆè¿™é‡Œæˆ‘ä»¬å°±å¯ä»¥è‡ªåŠ¨æ„å»ºå·¦å­æ ‘å’Œå³å­æ ‘äº†ï¼‰
        root.left = build(nums, lo, index - 1);
        root.right = build(nums, index + 1, hi);

        return root;
    }



    public static void main(String[] args) {
        // è¿™é‡Œæˆ‘ä»¬åˆå§‹åŒ–æ ‘
//        TreeNode root = new TreeNode(1);
//        root.left = new TreeNode(2);
//        root.right = new TreeNode(5);
//        root.left.left = new TreeNode(3);
//        root.left.right = new TreeNode(4);
//        root.right.right = new TreeNode(6);
        int[] data = new int[]{3,2,1,6,0,5};
        TreeNode result = constructMaximumBinaryTree(new int[]{3,2,1,6,0,5});
        System.out.println(result);
    }
```

# é€šè¿‡å‰åºå’Œä¸­åºéå†ç»“æœæ„é€ äºŒå‰æ ‘

![image-20210129155310283](images/image-20210129155310283.png)

æˆ‘ä»¬çš„å®é™…ä»£ç å¦‚ä¸‹ï¼š

```java
    static TreeNode build(int[] preorder, int preStart, int preEnd,
                   int[] inorder, int inStart, int inEnd) {
        // å½“å…ˆåºèŠ‚ç‚¹çš„å€¼å¤§äºåç»­èŠ‚ç‚¹æ—¶ï¼Œæˆ‘ä»¬é€€å‡º
        if (preStart > preEnd) {
            return null;
        }

        // root èŠ‚ç‚¹å¯¹åº”çš„å€¼å°±æ˜¯å‰åºéå†æ•°ç»„çš„ç¬¬ä¸€ä¸ªå…ƒç´ 
        int rootVal = preorder[preStart];
        // rootVal åœ¨ä¸­åºéå†æ•°ç»„ä¸­çš„ç´¢å¼•ï¼ˆå› ä¸ºæ ‘ä¸­æ²¡æœ‰é‡å¤çš„å…ƒç´ ï¼Œæ‰€ä»¥æˆ‘ä»¬å¯ä»¥å¿«é€Ÿå®šä½åœ¨ä¸­åºéå†å‰çš„ä½ç½®ï¼‰
        int index = 0;
        for (int i = inStart; i <= inEnd; i++) {
            if (inorder[i] == rootVal) {
                index = i;
                break;
            }
        }
        
        // å› ä¸ºä¸­åºéå†æ˜¯å‰é¢æ˜¯å·¦èŠ‚ç‚¹ï¼Œä¸­é—´æ˜¯æ ¹èŠ‚ç‚¹ï¼Œåé¢æ˜¯å³èŠ‚ç‚¹
        int leftSize = index - inStart;

        // å…ˆæ„é€ å‡ºå½“å‰æ ¹èŠ‚ç‚¹
        TreeNode root = new TreeNode(rootVal);
        // é€’å½’æ„é€ å·¦å³å­æ ‘
        root.left = build(preorder, preStart + 1, preStart + leftSize,
                inorder, inStart, index - 1);

        root.right = build(preorder, preStart + leftSize + 1, preEnd,
                inorder, index + 1, inEnd);
        return root;
    }
    
    
    // æ„å»ºäºŒå‰æ ‘
    static public TreeNode buildTree(int[] preorder, int[] inorder) {
        // è¿™é‡Œæˆ‘ä»¬å¯¹äºŒå‰æ ‘è¿›è¡Œæ„å»º       
        return build(preorder, 0, preorder.length - 1,
                inorder, 0, inorder.length - 1);
    }


    public static void main(String[] args) {
        // è¿™é‡Œæˆ‘ä»¬åˆå§‹åŒ–æ ‘
//        TreeNode root = new TreeNode(1);
//        root.left = new TreeNode(2);
//        root.right = new TreeNode(5);
//        root.left.left = new TreeNode(3);
//        root.left.right = new TreeNode(4);
//        root.right.right = new TreeNode(6);
        TreeNode result = buildTree(new int[]{3,9,20,15,7},new int[]{9,3,15,20,7});
        System.out.println(result);
    }
```

å¯ä»¥çœ‹åˆ°ï¼Œæˆ‘ä»¬çš„ç®—æ³•å…¶å®å•¥éƒ½æ²¡æœ‰ï¼Œå´å®Œæˆäº†äºŒå‰æ ‘çš„æ„å»ºï¼Œè¿™å°±æ˜¯é€’å½’çš„ç¥å¥‡ä¹‹å¤„

![image-20210129160908127](images/image-20210129160908127.png)

è¿™ä¸ªæ˜¯æ ¹æ®å…ˆåºéå†å’Œä¸­åºéå†çš„å®šä¹‰æ¥åšçš„

è‡ªå·±å†™çš„goä»£ç å¦‚ä¸‹ï¼š

```go
// @Description https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal/
// @Author å°æ¸¸
// @Date 2021/01/29
package main

import (
	"fmt"
)

type TreeNode struct {
	Val int
	Left *TreeNode
	Right *TreeNode
}

// è¿™é‡Œæˆ‘ä»¬å¼€å§‹æ„é€ äºŒå‰æ ‘
func Build(preorder []int,preStart int,preEnd int,inorder []int,inStart int,inEnd int) *TreeNode {
	// é€’å½’ç»“æŸæ ‡å¿—
	if preStart>preEnd{
		return nil
	}
	// å…ˆç¡®å®šæœ€å¤§å€¼
	rootVal:=preorder[preStart]
	var index int
	// æ‰¾å‡ºæœ€å¤§å€¼åœ¨inorderä¸­çš„ä½ç½®
	for k,v:=range inorder{
		if v == rootVal{
			index = k
		}
	}
	root:=new(TreeNode)
	root.Val = rootVal
	leftSize:= index-inStart
	root.Left = Build(preorder,preStart+1,preStart+leftSize,inorder,inStart,index-1)
	root.Right = Build(preorder,preStart+leftSize+1,preEnd,inorder,index+1,inEnd)
	return root
}

// æ„é€ äºŒå‰æ ‘
func buildTree(preorder []int, inorder []int) *TreeNode {
	return Build(preorder,0,len(preorder)-1,inorder,0,len(inorder)-1)
}

func main()  {
	result:=buildTree([]int{3,9,20,15,7},[]int{9,3,15,20,7})
	fmt.Println(result)
}
```



[æ‰‹æŠŠæ‰‹å¸¦ä½ åˆ·äºŒå‰æ ‘ï¼ˆç¬¬ä¸‰æœŸï¼‰ - labuladongçš„ç®—æ³•å°æŠ„ (gitbook.io)](https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/shou-ba-shou-shua-er-cha-shu-xun-lian-di-gui-si-wei/er-cha-shu-xi-lie-3)

# å¯»æ‰¾é‡å¤å­æ ‘

![image-20210130101918621](images/image-20210130101918621.png)

è¿™ä¸ªé¢˜ç›®çš„éš¾ç‚¹åœ¨äºå¦‚ä½•å¯»æ‰¾é‡å¤çš„å€¼ï¼Œç­”æ¡ˆé‡Œé¢åˆ«äººç”¨çš„æ˜¯ä¸€ä¸ªåºåˆ—åŒ–çš„æ–¹å¼ï¼Œç„¶åé€šè¿‡æ¯”è¾ƒå­—ç¬¦ä¸²æ¥è¿›è¡Œåˆ¤æ–­ã€‚å®é™…ä»£ç 

```java
    // è®°å½•æ‰€æœ‰å­æ ‘ä»¥åŠå‡ºç°çš„æ¬¡æ•°
    HashMap<String, Integer> memo = new HashMap<>();
    // è®°å½•é‡å¤çš„å­æ ‘æ ¹èŠ‚ç‚¹
    LinkedList<TreeNode> res = new LinkedList<>();

    /* ä¸»å‡½æ•° */
    List<TreeNode> findDuplicateSubtrees(TreeNode root) {
        traverse(root);
        return res;
    }

    /* è¾…åŠ©å‡½æ•° */
    String traverse(TreeNode root) {
//        å½“åˆ°è¾¾æ ¹èŠ‚ç‚¹çš„æ—¶å€™æˆ‘ä»¬è¿”å›ä¸€ä¸ª #
        if (root == null) {
            return "#";
        }

        // è¿™ä¸€æ­¥æ˜¯åœ¨å¯¹äºŒå‰æ ‘è¿›è¡Œéå†
        String left = traverse(root.left);
        String right = traverse(root.right);
        // è¿™é‡Œæ˜¯å¯¹äºŒå‰æ ‘è¿›è¡Œåºåˆ—åŒ–ï¼Œæˆ‘ä»¬
        String subTree = left + "," + right+ "," + root.val;
        // getOrDefaultæ˜¯è·å–mapçš„å€¼ï¼Œå¦‚æœmapä¸å­˜åœ¨å°±è¿”å›è¿™ä¸ªé»˜è®¤çš„å€¼ï¼ˆæˆ‘ä»¬è¿™ä¸ªmapè®°å½•çš„æ˜¯é‡å¤çš„æ•°é‡ï¼‰
        int freq = memo.getOrDefault(subTree, 0);
        // å¤šæ¬¡é‡å¤ä¹Ÿåªä¼šè¢«åŠ å…¥ç»“æœé›†ä¸€æ¬¡
        // å¦‚æœé‡å¤åº¦ä¸º1ï¼Œå°±è¯´æ˜è¿™æ£µæ ‘æœ‰ä¸€ä¸ªå‘ç”Ÿäº†é‡å¤
        if (freq == 1) {
            res.add(root);
        }
        // ç»™å­æ ‘å¯¹åº”çš„å‡ºç°æ¬¡æ•°åŠ ä¸€
        memo.put(subTree, freq + 1);
        return subTree;
    }
```



# äºŒå‰æœç´¢æ ‘

![image-20210130103016881](images/image-20210130103016881.png)

![image-20210130103553447](images/image-20210130103553447.png)

è¿™ä¸ªé¢˜ç›®åˆ©ç”¨äº†BSTäºŒå‰æ ‘çš„æ€§è´¨ï¼Œä¸­åºéå†è·å–å‡ºæ’å

```java
int kthSmallest(TreeNode root, int k) {
    // åˆ©ç”¨ BST çš„ä¸­åºéå†ç‰¹æ€§
    traverse(root, k);
    return res;
}

// è®°å½•ç»“æœ
int res = 0;
// è®°å½•å½“å‰å…ƒç´ çš„æ’å
int rank = 0;
void traverse(TreeNode root, int k) {
    if (root == null) {
        return;
    }
    traverse(root.left, k);
    /* ä¸­åºéå†ä»£ç ä½ç½® */
    rank++;
    if (k == rank) {
        // æ‰¾åˆ°ç¬¬ k å°çš„å…ƒç´ 
        res = root.val;
        return;
    }
    /*****************/
    traverse(root.right, k);
}
```



# BSTè½¬åŒ–ä¸ºç´¯åŠ æ ‘

![image-20210130112338280](images/image-20210130112338280.png)



æŒ‰ç…§äºŒå‰æ ‘çš„é€šç”¨æ€è·¯ï¼Œéœ€è¦æ€è€ƒæ¯ä¸ªèŠ‚ç‚¹åº”è¯¥åšä»€ä¹ˆï¼Œä½†æ˜¯è¿™é“é¢˜ä¸Šå¾ˆéš¾æƒ³åˆ°ä»€ä¹ˆæ€è·¯ã€‚

BST çš„æ¯ä¸ªèŠ‚ç‚¹å·¦å°å³å¤§ï¼Œè¿™ä¼¼ä¹æ˜¯ä¸€ä¸ªæœ‰ç”¨çš„ä¿¡æ¯ï¼Œæ—¢ç„¶ç´¯åŠ å’Œæ˜¯è®¡ç®—å¤§äºç­‰äºå½“å‰å€¼çš„æ‰€æœ‰å…ƒç´ ä¹‹å’Œï¼Œé‚£ä¹ˆæ¯ä¸ªèŠ‚ç‚¹éƒ½å»è®¡ç®—å³å­æ ‘çš„å’Œï¼Œä¸å°±è¡Œäº†å—ï¼Ÿ

è¿™æ˜¯ä¸è¡Œçš„ã€‚å¯¹äºä¸€ä¸ªèŠ‚ç‚¹æ¥è¯´ï¼Œç¡®å®å³å­æ ‘éƒ½æ˜¯æ¯”å®ƒå¤§çš„å…ƒç´ ï¼Œä½†é—®é¢˜æ˜¯å®ƒçš„çˆ¶èŠ‚ç‚¹ä¹Ÿå¯èƒ½æ˜¯æ¯”å®ƒå¤§çš„å…ƒç´ å‘€ï¼Ÿè¿™ä¸ªæ²¡æ³•ç¡®å®šçš„ï¼Œæˆ‘ä»¬åˆæ²¡æœ‰è§¦è¾¾çˆ¶èŠ‚ç‚¹çš„æŒ‡é’ˆï¼Œæ‰€ä»¥äºŒå‰æ ‘çš„é€šç”¨æ€è·¯åœ¨è¿™é‡Œç”¨ä¸äº†ã€‚

**å…¶å®ï¼Œæ­£ç¡®çš„è§£æ³•å¾ˆç®€å•ï¼Œè¿˜æ˜¯åˆ©ç”¨ BST çš„ä¸­åºéå†ç‰¹æ€§**ã€‚

## å‡åºå’Œé™åºæ‰“å°èŠ‚ç‚¹

![image-20210130112424207](images/image-20210130112424207.png)

é¢˜ç›®è§£ç­”å¦‚ä¸‹



```java
TreeNode convertBST(TreeNode root) {
    traverse(root);
    return root;
}

// è®°å½•ç´¯åŠ å’Œ
int sum = 0;
void traverse(TreeNode root) {
    if (root == null) {
        return;
    }
    traverse(root.right);
    // ç»´æŠ¤ç´¯åŠ å’Œ
    sum += root.val;
    // å°† BST è½¬åŒ–æˆç´¯åŠ æ ‘
    root.val = sum;
    traverse(root.left);
}
```

# BSTçš„å¢åˆ æ”¹æŸ¥

éªŒè¯BST

```go
type TreeNode struct {
   Val   int
   Left  *TreeNode
   Right *TreeNode
}

func isValidBST(root *TreeNode) bool {
   return ValidBST(root,nil,nil)
}

/*
BFSå®šä¹‰å¦‚ä¸‹
1.èŠ‚ç‚¹çš„å·¦å­æ ‘åªåŒ…å«å°äºå½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
2.èŠ‚ç‚¹çš„å³å­æ ‘åªåŒ…å«å¤§äºå½“å‰èŠ‚ç‚¹çš„æ•°ã€‚
3.æ‰€æœ‰å·¦å­æ ‘å’Œå³å­æ ‘è‡ªèº«å¿…é¡»ä¹Ÿæ˜¯äºŒå‰æœç´¢æ ‘ã€‚

æ‰€ä»¥æˆ‘ä»¬åœ¨åˆ¤æ–­çš„æ—¶å€™éœ€è¦ç¡®ä¿å·¦å­æ ‘æ¯”æœ€å°çš„èŠ‚ç‚¹å°ï¼Œå³å­æ ‘æ¯”å°å¤§çš„èŠ‚ç‚¹å¤§
*/

// éªŒè¯äºŒå‰æ ‘(å› ä¸ºè¦æ»¡è¶³BSTçš„å®šä¹‰,æˆ‘ä»¬ä¼ å…¥ä¸€ä¸ªæœ€å°å€¼å’Œæœ€å¤§å€¼)
func ValidBST(node *TreeNode,min *TreeNode,max *TreeNode) bool {
   // è·³å‡ºå¾ªç¯æ¡ä»¶
   if node == nil{return true}
   // éªŒè¯ä¸€ä¸‹root
   if min!=nil && node.Val <= min.Val{return false}
   if max!=nil && node.Val >= max.Val{return false}
   // æœ€å
   return ValidBST(node.Left,min,node) && ValidBST(node.Right,node,max)
}
```

å¯¹åº”çš„é¢˜ç›®å¦‚ä¸‹

[98. éªŒè¯äºŒå‰æœç´¢æ ‘ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)](https://leetcode-cn.com/problems/validate-binary-search-tree/)

è¿™ä¸ªä¸œè¥¿çš„æ ¸å¿ƒéƒ¨åˆ†åœ¨äºå¦‚ä½•åˆ¤æ–­èŠ‚ç‚¹æ˜¯å¦ç¬¦åˆæ¡ä»¶ï¼Œä¸ä»…è¦ç¡®ä¿æ ¹èŠ‚ç‚¹ç¬¦åˆæ¡ä»¶æ¡ä»¶ï¼Œå¥½éœ€è¦ç¡®ä¿å…¨å±€ç¬¦åˆæ¡ä»¶ï¼Œæ¯”å¦‚ä¸‹é¢è¿™ç§æƒ…å†µ

![image-20210130140327716](images/image-20210130140327716.png)

## å¯¹äºŒå‰æ ‘è¿›è¡Œæœç´¢

é»˜è®¤æƒ…å†µä¸‹ï¼Œæˆ‘ä»¬å¯ä»¥ä½¿ç”¨æœ€ç®€å•çš„éå†æ¥å»å¯»æ‰¾ä¸€ä¸ªå€¼ï¼Œæ¯”å¦‚ä¸‹é¢è¿™ä¸ªæœ€ç®€å•çš„ç©·ä¸¾

```java
boolean isInBST(TreeNode root, int target) {
    if (root == null) return false;
    if (root.val == target) return true;
    // å½“å‰èŠ‚ç‚¹æ²¡æ‰¾åˆ°å°±é€’å½’åœ°å»å·¦å³å­æ ‘å¯»æ‰¾
    return isInBST(root.left, target)
        || isInBST(root.right, target);
}
```

![image-20210130141357477](images/image-20210130141357477.png)

![image-20210130141345324](images/image-20210130141345324.png)

å½“ç„¶æˆ‘ä»¬å¯ä»¥ç®€åŒ–æˆ‘ä»¬çš„ç®—æ³•ï¼Œåˆ©ç”¨äº† BST å·¦å°å³å¤§çš„ç‰¹æ€§ã€‚æ¥ç®€åŒ–æˆ‘ä»¬çš„ç®—æ³•

![image-20210130141624973](images/image-20210130141624973.png)

![image-20210130141615920](images/image-20210130141615920.png)

[æ‰‹æŠŠæ‰‹å¸¦ä½ åˆ·äºŒå‰æœç´¢æ ‘ï¼ˆç¬¬äºŒæœŸï¼‰ - labuladongçš„ç®—æ³•å°æŠ„ (gitbook.io)](https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/shou-ba-shou-shua-er-cha-shu-xun-lian-di-gui-si-wei/er-cha-sou-suo-shu-cao-zuo-ji-jin#zai-bst-zhong-cha-ru-yi-ge-shu)

å¯¹åº”é¢˜ç›®ï¼š[701. äºŒå‰æœç´¢æ ‘ä¸­çš„æ’å…¥æ“ä½œ - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)](https://leetcode-cn.com/problems/insert-into-a-binary-search-tree/submissions/)

## äºŒå‰æ ‘æ·»åŠ å…ƒç´ 

æˆ‘è‡ªå·±å†™çš„ç®—æ³•ï¼Œæˆ‘çœ‹äº†ä¸€ä¸‹åˆ«äººçš„ç®—æ³•ï¼Œæ„Ÿè§‰éƒ½å·®ä¸å¤š

```java
class Solution {
    public TreeNode insertIntoBST(TreeNode root, int val) {
        if(root==null){
            return new TreeNode(val);
        }
        // åˆ¤æ–­å¤§å°
        if(val > root.val){
            root.right = insertIntoBST(root.right,val);
        }else{
            root.left = insertIntoBST(root.left,val);
        }
        return root;
    }
}
```

```java
TreeNode insertIntoBST(TreeNode root, int val) {
    // æ‰¾åˆ°ç©ºä½ç½®æ’å…¥æ–°èŠ‚ç‚¹
    if (root == null) return new TreeNode(val);
    // if (root.val == val)
    //     BST ä¸­ä¸€èˆ¬ä¸ä¼šæ’å…¥å·²å­˜åœ¨å…ƒç´ 
    if (root.val < val) 
        root.right = insertIntoBST(root.right, val);
    if (root.val > val) 
        root.left = insertIntoBST(root.left, val);
    return root;
}
```

## äºŒå‰æ ‘åˆ é™¤å…ƒç´ 

åˆ é™¤å…ƒç´ çš„éš¾ç‚¹åœ¨äºåˆ é™¤å¹¶ä¸åªæ˜¯ç®€å•çš„åˆ é™¤å°±è¡Œï¼Œè¿˜è¦ç¡®ä¿åˆ é™¤åæ•´ä¸ªäºŒå‰æ ‘å¯ä»¥ç»´æŒè‡ªå·±çš„æ€§è´¨ä¸å˜

![image-20210130143052906](images/image-20210130143052906.png)

```java
TreeNode deleteNode(TreeNode root, int key) {
    if (root == null) return null;
    if (root.val == key) {
        // è¿™ä¸¤ä¸ª if æŠŠæƒ…å†µ 1 å’Œ 2 éƒ½æ­£ç¡®å¤„ç†äº†
        if (root.left == null) return root.right;
        if (root.right == null) return root.left;
        // å¤„ç†æƒ…å†µ 3ï¼Œ é¦–å…ˆè¦æ‰¾å‡ºæœ€å°çš„èŠ‚ç‚¹ï¼Œç„¶åæˆ‘ä»¬ä¿®æ”¹è¿™ä¸ªèŠ‚ç‚¹çš„å€¼å¹¶åˆ é™¤æœ€å°çš„é‚£ä¸ªèŠ‚ç‚¹
        TreeNode minNode = getMin(root.right);
        root.val = minNode.val;
        root.right = deleteNode(root.right, minNode.val);
    } else if (root.val > key) {
        root.left = deleteNode(root.left, key);
    } else if (root.val < key) {
        root.right = deleteNode(root.right, key);
    }
    return root;
}

TreeNode getMin(TreeNode node) {
    // BST æœ€å·¦è¾¹çš„å°±æ˜¯æœ€å°çš„
    while (node.left != null) node = node.left;
    return node;
}
```

# äºŒå‰æ ‘åºåˆ—åŒ–

å¯¹åº”é¢˜ç›®ï¼š[297. äºŒå‰æ ‘çš„åºåˆ—åŒ–ä¸ååºåˆ—åŒ– - åŠ›æ‰£ï¼ˆLeetCodeï¼‰ (leetcode-cn.com)](https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree/)

å¯¹åº”ç¬”è®°ï¼š[äºŒå‰æ ‘çš„åºåˆ—åŒ–ï¼Œå°±é‚£å‡ ä¸ªæ¡†æ¶ï¼Œæ¯ç‡¥è‡³æ - labuladongçš„ç®—æ³•å°æŠ„ (gitbook.io)](https://labuladong.gitbook.io/algo/shu-ju-jie-gou-xi-lie/shou-ba-shou-shua-er-cha-shu-xun-lian-di-gui-si-wei/er-cha-shu-de-xu-lie-hua)

å¾®ä¿¡å…¬ä¼—å·æ–‡ç« ï¼š[äºŒå‰æ ‘çš„é¢˜ï¼Œå°±é‚£å‡ ä¸ªæ¡†æ¶ï¼Œæ¯ç‡¥è‡³æğŸ¤” (qq.com)](https://mp.weixin.qq.com/s/DVX2A1ha4xSecEXLxW_UsA)

å‰åºéå†è§£æ³•ï¼š

```java
String SEP = ",";
String NULL = "#";

/* ä¸»å‡½æ•°ï¼Œå°†äºŒå‰æ ‘åºåˆ—åŒ–ä¸ºå­—ç¬¦ä¸² */
String serialize(TreeNode root) {
    StringBuilder sb = new StringBuilder();
    serialize(root, sb);
    return sb.toString();
}

/* è¾…åŠ©å‡½æ•°ï¼Œå°†äºŒå‰æ ‘å­˜å…¥ StringBuilder */
void serialize(TreeNode root, StringBuilder sb) {
    if (root == null) {
        sb.append(NULL).append(SEP);
        return;
    }

    /****** å‰åºéå†ä½ç½® ******/
    sb.append(root.val).append(SEP);
    /***********************/

    serialize(root.left, sb);
    serialize(root.right, sb);
}

/* ä¸»å‡½æ•°ï¼Œå°†å­—ç¬¦ä¸²ååºåˆ—åŒ–ä¸ºäºŒå‰æ ‘ç»“æ„ */
TreeNode deserialize(String data) {
    // å°†å­—ç¬¦ä¸²è½¬åŒ–æˆåˆ—è¡¨
    LinkedList<String> nodes = new LinkedList<>();
    for (String s : data.split(SEP)) {
        nodes.addLast(s);
    }
    return deserialize(nodes);
}

/* è¾…åŠ©å‡½æ•°ï¼Œé€šè¿‡ nodes åˆ—è¡¨æ„é€ äºŒå‰æ ‘ */
TreeNode deserialize(LinkedList<String> nodes) {
    if (nodes.isEmpty()) return null;

    /****** å‰åºéå†ä½ç½® ******/
    // åˆ—è¡¨æœ€å·¦ä¾§å°±æ˜¯æ ¹èŠ‚ç‚¹
    String first = nodes.removeFirst();
    if (first.equals(NULL)) return null;
    TreeNode root = new TreeNode(Integer.parseInt(first));
    /***********************/

    root.left = deserialize(nodes);
    root.right = deserialize(nodes);

    return root;
}
```

åºåˆ—åŒ–æ¯”è¾ƒç®€å•ï¼Œåªéœ€è¦å¯¹æ•°æ®è¿›è¡Œå‰åºéå†æ“ä½œï¼Œç„¶åæŠŠæˆ‘ä»¬çš„æ•°æ®æ‹¼æ¥æˆå­—ç¬¦ä¸²ï¼Œ

ååºåˆ—åŒ–éœ€è¦æ ¹æ®æˆ‘ä»¬çš„éå†ï¼Œåè¿‡æ¥å»æ¨å¯¼æœ€åçš„äºŒå‰æ ‘



