10大排序算法

![img](images/0B319B38-B70E-4118-B897-74EFA7E368F9.png)

# 插入排序

插入排序是最简单的，我们不断比较插入数据

```go
// 插入排序
func insertSort(arr []int )[]int{
   var j = 0
   for i := 1; i < len(arr); i++ {
      // 定义临时变量暂存当前位置数据
      tmp := arr[i]
      // j为当前位置，我们不断把数据往后移，直到找到比tmp小或者j>0时结束
      for j = i; j > 0 && tmp < arr[j - 1]; j-- {
         // 移动时我们的数字要不断往后移
         arr[j] = arr[j - 1]
      }
      // 最后这个j就是我们空出来的，这个时候我们把tmp值放入
      arr[j] = tmp
   }
   return arr
}


// 主函数
func main()  {
   fmt.Println(insertSort([]int{38,65,97,76,13,27,49}))
}
```

插入排序的思想如下

![image-20210128094237098](images/image-20210128094237098.png)

时间复杂度为o(n^2) 空间复杂度为o(1)

我的错误代码

![image-20210128094858445](images/image-20210128094858445.png)

# 折半插入排序

![image-20210128102903185](images/image-20210128102903185.png)

```go
// 折半插入排序
func BInsertSort(arr []int) []int {
	// 变量定义
	var i,j,mid int;var low=0;var high =0;var tmp =0
	// 遍历数组
	for i = 1; i<len(arr);i++{
		// 定义折半查找变量
		low=0;high=i-1;tmp=arr[i]
		// 我们使用折半查找，来找出比刚好比tmp节点大的节点（再往前一个就小）
		for low <= high{
			// 求中值
			mid = (high+low) / 2
			// 判断中值和tmp的，如果比tmp大，我们的high就需要减小，然后再进行比较
			if arr[mid] > tmp{
				high = mid -  1
			}else{
				low = mid + 1
			}
		}
		// 最后我们可以确定这个low就是我们要插入的地方，我们把low后面的节点整体
		for j=i;j>low;j--{
			arr[j] = arr[j-1]
		}
		// 替换low节点
		arr[low] = tmp
	}
	return arr
}
```

时间复杂度为o(n^2) 时间复杂度为O(1)

# 希尔排序







